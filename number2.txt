Кратко Скопировать ссылку "Кратко"
С помощью функции fetch() можно отправлять сетевые запросы на сервер — как получать, так и отправлять данные. Метод возвращает промис с объектом ответа, где находится дополнительная информация (статус ответа, заголовки) и ответ на запрос.

Как понять Скопировать ссылку "Как понять"
Браузер предоставляет глобальный API для работы с запросами и ответами HTTP. Раньше для подобной работы использовался XMLHttpRequest, однако fetch() более гибкая и мощная альтернатива, он понятнее и проще в использовании из-за того, что использует Promise.

Как пишется Скопировать ссылку "Как пишется"
Функция fetch() принимает два параметра:

url — адрес, по которому нужно сделать запрос;
options (необязательный) — объект конфигурации, в котором можно настроить метод запроса, тело запроса, заголовки и многое другое.
По умолчанию вызов fetch() делает GET-запрос по указанному адресу. Базовый вызов для получения данных можно записать таким образом:

fetch('http://jsonplaceholder.typicode.com/posts')

Скопировать
Результатом вызова fetch() будет Promise, в котором будет содержаться специальный объект ответа Response. У этого объекта есть два важных для нас поля:

ok — принимает состояние true или false и сообщает об успешности запроса;
json — метод, вызов которого, возвращает результат запроса в виде json.
В следующем примере используем .then() - обработчик результата, полученного от асинхронной операции. Обработчик дождётся ответа от сервера, принимает ответ, и, в данном случае, неявно возвратит ответ, обработанный методом .json();

fetch('http://jsonplaceholder.typicode.com/posts')
  // функция then вернет другой промис (их можно чейнить). Когда отрезолвится промис (r.json()), который вернула функция then, будет вызван следующий колбек в цепочке
  .then((response) => response.json())
  // Получим ответ в виде массива из объектов [{...}, {...}, {...}, ...]

Скопировать
С помощью второго аргумента options можно передать настройки запроса. Например, можно изменить метод и добавить тело запроса, если мы хотим не получать, а отправлять данные. Так же в запрос можно добавить заголовки в виде объекта или специального класса Headers.

const newPost = {
  title: 'foo',
  body: 'bar',
  userId: 1,
}

fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST', // Здесь так же могут быть GET, PUT, DELETE
  body: JSON.stringify(newPost), // Тело запроса в JSON-формате
  headers: {
    // Добавляем необходимые заголовки
    'Content-type': 'application/json; charset=UTF-8',
  },
})
  .then((response) => response.json())
  .then((data) => {
    console.log(data)
    // {title: "foo", body: "bar", userId: 1, id: 101}
  })

Скопировать
Cookies Скопировать ссылку "Cookies"
По умолчанию fetch() запросы не включают в себя cookies и потому авторизованные запросы на сервере могут не пройти. Для этого необходимо добавить в настройку поле credentials:

fetch('https://somesite.com/admin', {
  method: 'GET',
  // или 'same-origin' если можно делать такие запросы только в пределах этого домена
  credentials: 'include',
})

Скопировать
Обработка ошибок Скопировать ссылку "Обработка ошибок"
Любой ответ на запрос через fetch() (например HTTP-код 400, 404 или 500) переводит Promise в состояние fulfilled. Промис перейдёт в состояние rejected только если запрос не случился из-за сбоя сети или что-то помешало выполнению fetch().

// Запрос вернет ошибку 404 Not Found
fetch('https://jsonplaceholder.typicode.com/there-is-no-such-route').catch(
  () => {
    console.log('Error occurred!')
  }
) // Никогда не выполнится

Скопировать
Чтобы обработать ошибку запроса, необходимо обращать внимание на поле ok в объекте ответа Response. В случае ошибки запроса оно будет равно false.

fetch('https://jsonplaceholder.typicode.com/there-is-no-such-route')
  .then((response) => {
    // Проверяем успешность запроса и выкидываем ошибку
    if (!response.ok) {
      throw new Error('Error occurred!')
    }

    return response.json()
  })
  // Теперь попадём сюда, т.к выбросили ошибку
  .catch((err) => {
    console.log(err)
  }) // Error: Error occurred!


  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  fetch('https://jsonplaceholder.typicode.com/todos', {
      method: 'POST',
      body: JSON.stringify({
        userId: 1,
        title: "buy vegetables",
        completed: true
      }),
      headers: {
        "Content-type": "application/json; charset=UTF-8"	
      }
    })
    .then(response => response.json())
    .then(json => console.log(json))

----------------------------------------------------------------------
получить тип даних с сервера и взависимости клеить value

Перегрузка в JavaScript
Допускает ли Javascript перегрузку функций? Строго говоря, нет. 
Мы можем выполнить что-то похожее, но у такого подхода есть 
ряд недостатков. А какие — узнаем, рассмотрев несколько примеров.

Допустим, нужно создать функцию concatString, принимающую от 1–3 строковых параметров:

function concatString(s1, s2, s3) {
  let s = s1;
  if(s2) {
    s += `, ${s2}`;
  }
  if(s3) {
    s += `, ${s3}`;
  }
  return s;
}

concatString('one');
concatString('one','two');
concatString('one', 'two', 'three');
Выглядит отлично. Но что произойдет, если вызвать этот 
метод следующим образом?

concatString('one', true);
Метод выполнится, но вернет неправильный результат. 
Это легко исправить. Проверим, чтобы аргументы typeof 
принимали только строки:

if(s2 && typeof s2 === 'string')
Таким образом, проблема с разными типами “решена”. А что если 
вызвать метод с разным числом аргументов? Вот одно быстрое решение. 
Мы можем проверить свойство length у arguments и вернуть ошибку 
в случае его превышения. В следующем примере оно будет равняться 3.

function concatString(s1, s2, s3) {
  if (arguments.length > 3) {
    throw new Error('signature not supported');
  }
  let s = s1;
  if(s2 && typeof s2 === 'string') {
    s += `, ${s2}`;
  }
  if(s3 && typeof s3 === 'string') {
    s += `, ${s3}`;
  }
  return s;
}
Глядя на этот пример, нетрудно понять, почему сообщество Javascript 
предпочитает игнорировать перегрузку. Методы разрастаются, их 
становится все сложнее читать и поддерживать. 
А ошибки обнаруживаются только во время выполнения.


Убрать дубли при создании tablebody